# System Call Handler

An important part of any operating system are system calls. Interacting with a system's hardware and resources require privileged access. By providing system calls, user programs can request the kernel to perform operations needed by the program while dicting how the call itself is performed.
This allows the kernel to:

- Protect system integrity, ensuring no program can corrupt kernel state or access unauthorized memory.

- Enforce security, preventing direct access to sensitive resources.

- Provide abstraction, letting user programs work with simple APIs rather than complex hardware details.

## Implementation

For our kernel, we created kernel traps in a manner similar to Linux. Linux uses registers X1-X5 to pass the system call arguments and X8 for the specific opcode to distinguish what system call is being made.

## Background

Before diving into the specifics of implementing system calls, some background on what a system call is on ARMv8 is needed and the instructions used to generate the call itself.

### Exceptions

For the ARMv8 architecture, systems calls fall under a specific type of exception. There are synchronous exceptions, which are generated by certain instructions such as dividing by 0 or accessing invalid memory, and there are asynchronous exceptions that are not related to the instruction being executed. These could be generated by a timer interrupt for example. In ARMv8, there are four types of exceptions that fall into synchronous or asynchronous.

The four types of exceptions are:

- **IRQ** (interrupt request) - these are a form of asynchronous exceptions generated by hardware
- **FIQ** (fast interrupt request) - similar to IRQs, but prioritized over IRQs and are usually given their own handler
- **SError** (system error) - another asynchronous exception, usually generated by a hardware failure.
- **Synchronous Exception** - the fourth type of exception and is always generated by an instruction. These can be intentional through a system call, or unintentional by executing illegal instructions such as dividing by 0.

# Generating a System Call
To generate a system call, a user program needs a way to notify the kernel it is requesting the kernel to do something on its behalf. This is done by generating a synchronous exception. ARM provides a set of instructions to do this. 
The Arm64 documentation states:

"In A64, there are special instructions for making such system calls. These instructions cause an exception, which allows controlled entry into a more privileged Exception level."
- ***SVC*** Supervisor call causes an exception targeting EL1. Used by an application to call the OS.
- ***HVC*** Hypervisor call causes an exception targeting EL2. Used by an OS to call the hypervisor, not available at EL0.
- ***SMC*** Secure monitor call causes an exception targeting EL3. Used by an OS or hypervisor to call the EL3 firmware, not available at EL0.

***Note:*** *"If an exception is executed from an Exception level higher than the target exception level, then the exception is taken to the current Exception level. This means that an SVC at EL2 would cause exception entry to EL2. Similarly, an HVC at EL3 causes exception entry to EL3. This is consistent with the rule that an exception can never cause the processor to lose privilege."*

###### These definitions come straight from [ARM](https://developer.arm.com/documentation/102374/0102/System-calls)

The instruction we care about is SVC as we want to provide a way for the user to trap into the kernel by causing an exception.


## User Side
On the user side, we need a simple and clean interface for programs to request services from the kernel through system calls. We accomplish this by:

- Defining identifiers for each system call.

- Providing C/C++ functions that user programs can call.

- Implementing assembly stubs that move the correct system call number into the appropriate register and execute the svc instruction to trap into the kernel.

The identifiers and functions can be provided in a header file to the user program
```
// syscall.h
#define SYS_WRITE  1
#define SYS_READ   2
#define SYS_EXIT   3

// Function prototypes for user programs
int sys_write(const char *buf, int size);
int sys_read(char *buf, int size);
void sys_exit(int status);
```
And matching assembly stubs in a .S file
```
// syscall.S
.global sys_write
.global sys_read
.global sys_exit

// int sys_write(const char *buf, int size)
sys_write:
    mov x8, #SYS_WRITE    // Load system call number
    svc #0                // Generate synchronous exception
    ret                   // Return to caller

// int sys_read(char *buf, int size)
sys_read:
    mov x8, #SYS_READ
    svc #0
    ret

// void sys_exit(int status)
sys_exit:
    mov x8, #SYS_EXIT
    svc #0
    ret
```

We chose to place the identifiers in x8 because we wanted to port NewLib and attempt to match Linux system calls.

Before moving on to what the kernel side needs, it is important to understand how arguments are passed. AArch64 Procedure Call Standard passes arguments and return values using registers x0-x8. In the assembly stub, we have done a ***mov*** to get the opcode into the register. The remaining arguments are placed into registers x0-x5 (mirroring Linux ABI) when the corresponding function from the header file is called. 

For example:
``` 
int main() {
    my_sys_call(1, 2, 3);
    exit(1);
}
```
When the user program calls *my_sys_call(1, 2, 3);* 1, 2, 3 will be placed into registers x0-x2 and then the kernel trap is invoked.
``` 
.global my_sys_call
my_sys_call:
    mov x8, #SYS_MY_SYSCALL
    svc #0
    ret
```
This places the my_sys_call identifier into x8 with the ***mov*** instruction as stated before.

## Kernel Side
On the kernel side, we need to identify what system call was made and handle accordingly. This is done by:
- initializing vector table
- identifying the type of synchronous exception
- retrieving the arguments and branching to the system call handler
- return any value requested or -1 to indicate a failure.

### Vector Table
ARMv8 requires that when an exception occurs, the processor must know where to jump to start handling it. This is done through the vector table. The VBAR_EL1 (Vector Base Address Register at EL1) holds the address of the table.

Each entry in the vector table is a branch to a specific handler based on the type of exception.

This can be acomplished when booting into the system by setting **VBAR_EL1** to a predefined table

First we can define the table as the following:
```
.macro ventry label
.align	7
b	\label
.endm


    // important, code has to be properly aligned
    .align 11
_vectors:
    ventry synchronous_el0
    ventry irq_el0
    ventry fiq_el0
    ventry serror_el0
    
    ventry synchronous_el1
    ventry irq_el1
    ventry fiq_el1
    ventry serror_el1
    
    ventry synchronous_el0_64
    ventry irq_el0_64
    ventry fiq_el0_64
    ventry serror_el0_64
    
    ventry synchronous_el0_32
    ventry irq_el0_32
    ventry fiq_el0_32
    ventry serror_el0_32

```
Once this table is defined, we can set **VBAR_EL1** to this table. This must be done for every core. If desired, a different table could be created for each core.

```
    ldr     x0, =_vectors
    msr     vbar_el1, x0
```
Now, when SVC is called, the CPU will branch to synchronous_el0 (this could also be synchronous_el0_64 if the program is using **SP_EL1** or **synchronous_el0_32** if the program is running in 32-bit mode).

Now we can define what synchronous_el0 is
```
synchronous_el0:
    kernel_entry
    mov x0, sp

    mrs     x1, esr_el1         // ESR_EL1 has EC in bits [31:26]
    lsr     x2, x1, #26         // x2 = EC = ESR_EL1[31:26]
    cmp     x2, #0x15           // 0x15 = SVC from EL0
    b.ne    not_syscall         // if not SVC, go handle as exception
    
    // It's an SVC -> syscall
    bl syscall_handler
    kernel_exit                 // returns to user via eret
```

Let's breakdown this code.
kernel_entry is a macro to save the CPU context of when the exception occurred onto the stack. This is important because we can get the arguments desired from here.

kernel_exit will pop all the register values back off of the stack and back into the registers. This is important because if a value is to be returned to the user, we want to place it where x0 was stored on the stack.
```
.macro	kernel_entry
	sub	sp, sp, #S_FRAME_SIZE
	stp	x0, x1, [sp, #16 * 0]
	stp	x2, x3, [sp, #16 * 1]
	stp	x4, x5, [sp, #16 * 2]
	stp	x6, x7, [sp, #16 * 3]
	stp	x8, x9, [sp, #16 * 4]
	stp	x10, x11, [sp, #16 * 5]
	stp	x12, x13, [sp, #16 * 6]
	stp	x14, x15, [sp, #16 * 7]
	stp	x16, x17, [sp, #16 * 8]
	stp	x18, x19, [sp, #16 * 9]
	stp	x20, x21, [sp, #16 * 10]
	stp	x22, x23, [sp, #16 * 11]
	stp	x24, x25, [sp, #16 * 12]
	stp	x26, x27, [sp, #16 * 13]
	stp	x28, x29, [sp, #16 * 14]
	str	x30, [sp, #16 * 15] 
	.endm

.macro	kernel_exit
	ldp	x0, x1, [sp, #16 * 0]
	ldp	x2, x3, [sp, #16 * 1]
	ldp	x4, x5, [sp, #16 * 2]
	ldp	x6, x7, [sp, #16 * 3]
	ldp	x8, x9, [sp, #16 * 4]
	ldp	x10, x11, [sp, #16 * 5]
	ldp	x12, x13, [sp, #16 * 6]
	ldp	x14, x15, [sp, #16 * 7]
	ldp	x16, x17, [sp, #16 * 8]
	ldp	x18, x19, [sp, #16 * 9]
	ldp	x20, x21, [sp, #16 * 10]
	ldp	x22, x23, [sp, #16 * 11]
	ldp	x24, x25, [sp, #16 * 12]
	ldp	x26, x27, [sp, #16 * 13]
	ldp	x28, x29, [sp, #16 * 14]
	ldr	x30, [sp, #16 * 15] 
	add	sp, sp, #S_FRAME_SIZE		
	eret
	.endm
```
First, we save the CPU context and save a pointer to the context in x0. This will get passed to the system call handler
```
    kernel_entry
    mov x0, sp
```


### Identifying Synchronous Exception
Next, we need to actually check if the instruction generating a synchronous error is from the instruction ***SVC***

**esr_el1** is the [Exception Syndrome Register (EL1)](https://developer.arm.com/documentation/ddi0601/2025-03/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-) and is used to identify what caused the synchronous exception.
- Exception class bits are [31:26] so we lsr by 26.
- 0b010101 means SVC instruction execution in AArch64 state which is 0x15
- If esr_el1 contained 0x15, then we know a system call was made

```
    mrs     x1, esr_el1         // ESR_EL1 has EC in bits [31:26]
    lsr     x2, x1, #26         // x2 = EC = ESR_EL1[31:26]
    cmp     x2, #0x15           // 0x15 = SVC from EL0
    b.ne    not_syscall         // if not SVC, go handle as exception
    
    // It's an SVC -> syscall
    bl syscall_handler
```

Once handled we can safely return back to the user
```
kernel_exit                 // returns to user via eret
```

### Retrieving Arguments and Return Value
Once in the handler, you have the freedom to set things up however you want.
We created a KernelEntryFrame struct to match with our macro.
```
// KernelEntryFrame structure.
// X[0] - return value
struct KernelEntryFrame {
    union {
        /* X[0] ... X[5] - arguments
        once function is called, X[0] will be the return value.
        */
        uint64_t X[31];  // 0 ... 30
    };
};
```
Since we moved the address of where the CPU context was saved into x0, we can branch to syscall_handler given the parameter *KernelEntryFrame** *frame*. Here is an example of what the handler could look like.
```
void syscall_handler(KernelEntryFrame* frame) {
    // printf("hello\n");
    int opcode = frame->X[8];
    switch (opcode) {
        case NEWLIB_EXIT:
            newlib_handle_exit(frame);
            break;
        case NEWLIB_CLOSE:
            printf("SYS_CLOSE\n");
            newlib_handle_close(frame);
            K::assert(false, "RACE DETECTED IN CLOSE");
            break;
        case NEWLIB_EXEC:
            frame->X[0] = newlib_handle_exec(frame);
            K::assert(false, "RACE DETECTED IN EXEC");
            break;
        default:
            break;
    }
}
```

# Conclusion
When creating an OS, you have lots of freedom to design your own system calls. What you decide should be based on your goals and what you want to learn/achieve. You could write completely custom system calls, but many programs will expect Linux behaving system calls. If your goal is to run existing programs, emulating the behavior of Linux will be your best route. We chose to follow Linux as closely as we could, and picked a subset of system calls needed for NewLib and running Doom. My motivation behind creating this tutorial and documentation was because when doing this myself, I found that OSdev only had one page for ARM system calls, but it happened to be for [AArch32](https://wiki.osdev.org/ARM_System_Calls). This was not helpful for our kernel development, so I wanted to make a guide based on the decisions we made.

### Resources

- [Arm System Calls](https://developer.arm.com/documentation/102374/0102/System-calls)
- [Porting New Lib](https://wiki.osdev.org/Porting_Newlib)
- [New Lib System Calls](https://sourceware.org/newlib/libc.html#Syscalls)
- [Exception Syndrome Register](https://developer.arm.com/documentation/ddi0601/2025-03/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-)
- [System Call Table](https://arm64.syscall.sh/)
