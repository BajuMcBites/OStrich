# System Call Handler

An important part of any operating system are system calls. Interacting with a system's hardware and resources require privileged access. By providing system calls, user programs can request the kernel to perform operations needed by the program while dicting how the call itself is performed.
This allows the kernel to:

- Protect system integrity, ensuring no program can corrupt kernel state or access unauthorized memory.

- Enforce security, preventing direct access to sensitive resources.

- Provide abstraction, letting user programs work with simple APIs rather than complex hardware details.

## Implementation

For our kernel, we created kernel traps in a manner similar to linux. Linux uses registers X1-X5 to pass the system call arguments and X8 for the specific opcode to distinguish what system call is being made.

## Background

Before diving into the specifics of implementing system calls, some background on what a system call is on ARMv8 is needed and the instructions used to generate the call itself.

### Exceptions

For the ARMv8 architecture, systems calls fall under a specific type of exception. There are synchronous exceptions which are generated by certain instructions such as diving by 0 or accessing invalid memory, and there are asynchronous exceptions that are not related to the instruction being excecuted. These could be generated by a timer interrupt for example. In ARMv8, there are four types of interrupts that fall into synchronous or asynchronous.

The four types of exceptions are:

- **IRQ** (interrupt request)
- **FIQ** (fast interrupt request)
- **SError** (system error)
- **Synchronous Exception**

```
int sys_call_1(void * arg1, int arg2, ...);
```

```
 .global sys_call_1
 sys_call_1:
     mov x8, #CALL1
     svc #0
     ret
```

### Resources

- [Arm System Calls](https://developer.arm.com/documentation/102374/0102/System-calls)
