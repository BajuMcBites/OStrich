.globl memzero
memzero:
	str xzr, [x0], #8
	subs x1, x1, #8
	b.gt memzero
	ret

.macro init_inner_table start_addr, temp
    add \temp, \start_addr, #4096   
    lsr \temp, \temp, #12  
    and \temp, \temp, #0xFFFFFFFFF  
    lsl \temp, \temp, #12    
    orr \temp, \temp, #3 
    str \temp, [\start_addr]
.endm

.macro insert_pmd_entry str_addr, phys_bits, temp1, temp2
	and \temp1, \phys_bits, #0xFFFFFFF
	lsl \temp1, \phys_bits, #20
	movz \temp2, #0x405 // set flags: no cache (3rd bit is 1), mm access (11th bit), valid type (1st bit)
	orr \temp1, \temp1, \temp2 
	str \temp1, [\str_addr]
.endm

.macro init_pmd_table_entries start_addr, entry_num, temp1, temp2
	movz \entry_num, #0
1:
	insert_pmd_entry \start_addr, \entry_num, \temp1, \temp2
	add \start_addr, \start_addr, #8
	add \entry_num, \entry_num, #1
	cmp \entry_num, #512
	blt 1b
.endm

.global create_page_tables
create_page_tables:
	mov    x29, x30

	// clear page tables to 0
	adr    x0, __paging_start
    adr    x1, __paging_end
    sub    x1, x1, x0
    bl     memzero

	adr    x0, __paging_start

	//set up PGD -- ins addr: 0x809dc
	init_inner_table x0, x1

	//set up PUD
	add x0, x0, #4096
	init_inner_table x0, x1

	// set up PMD entries
	add x0, x0, #4096
	init_pmd_table_entries x0, x1, x2, x3

	mov x30, x29
	ret

	// update sp, load page table into register, turn on mmu
	// Define necessary constants
// .equ VA_START, 0xFFFF000000000000
// .equ LOW_MEMORY, 0x80000
// remove these values later:
.equ TCR_VALUE, 0x850102010 
.equ MAIR_VALUE, 0x4444444444444444 //change this, but theoretically all are now normal, noncacheable
.equ SCTLR_MMU_ENABLED, 0x1
.equ VA_START, 0xFFFF000000000000

.global init_mmu
init_mmu:
    // Update stack pointer to use a virtual address
	movz x4, #0xFFFF
	lsl x4, x4, #48
	add sp, sp, x4

    //base address of the page table into ttbr1_el1
    adr x0, __paging_start
	orr x0, x0, #1
    msr ttbr1_el1, x0
    msr ttbr0_el1, x0 //added

    //Translation Control Register
    ldr x0, =(TCR_VALUE)
    msr tcr_el1, x0

    //Memory Attribute Indirection Register
    ldr x0, =(MAIR_VALUE)
    msr mair_el1, x0

	// load into return register
	// add x30, x30, x4

    // Enable the MMU ?? (can't find the register)
	mrs x0, sctlr_el1
    orr x0, x0, #SCTLR_MMU_ENABLED 
    msr sctlr_el1, x0 //error here for some reason
	
	movz x0, #0xffff
	mov x1, x4
	//mov x1, xzr
	movz x5, #0x831
	lsl x5, x5, #8
	orr x1, x1, x5 //addr: 0x80a94
	str x0, [x1]
	ret
	// error message
    // 000010010110000000000000000001000100
	// 543210987654321098765432109876543210
	// Translation fault, level 0.
	// Abort caused by an instruction writing to a memory location.
	// Data Abort exception taken without a change in Exception level.
    // Used for MMU faults generated by data accesses, alignment faults other 
	// than those caused by Stack Pointer misalignment, and synchronous External aborts, 
	// including synchronous parity or ECC errors. Not used for debug-related exceptions.


	//TG1 -> granual size of ttbr1_el1 [31:30] -> 4kb 0b10
	//T1SZ -> size offset of the memory region addressed by TTBR1_el1, region size is 2^(64-T1SZ) [21:16] (want to be 16)-> 0b010000 ****
	//sh1 -> Shareability attribute for memory associated with translation table walks using TTBR1_EL1. (i think we want [inner] 
	//shareable, but will set outer sharebale since it seems stronger) [29:28] -> 0b10 *****
	//ORGN1 -> Outer cacheability attribute for memory associated with translation table walks using TTBR1_EL1.  (non cacheable i think is the safest) [27:26] -> 0b00 *****
	//IRGN1 -> same as above but inner memory [25:24] -> 0b00 *****
	//EPD1 -> Translation table walk disable for translations using TTBR1_EL1. This bit controls whether
	//a translation table walk is performed on a TLB miss, for an address that is translated using TTBR1_EL1. [23] -> 0b0 *****

	//T0SZ, bits [5:0] -> 0b010000 ****
	//EPD0, use ttbr0_el1 for translation bit [7] -> 0b0 ***
	//IRGN0, bits [9:8] -> 0b00 ***
	//ORGN0, bits [11:10] -> 0b00 ***
	//SH0, bits [13:12] -> 0b10 ***
	//TG0, granual size for ttbr0_el1 [15:14] 4kb -> 0b00 ***

	//A1, which changes on a context switch (not too sure tho) bit [22] -> 0b0 ****

	//AS, 16 bit - the upper 16 bits of TTBR0_EL1 and TTBR1_EL1 are used for allocation and matching in the TLB. bit [36] -> 0b1 *****

	//IPS, we have 1 gig of ram so 4gb is the smallest: [34:32] 0b000

	//TBI0, are we ignoring for ttbr0_el1 the top byte to use as metadada, probably not: bit [37] -> 0b0
	//TBI1, same thing as ^ for ttbr1_el1 bit [38] -> 0b0
	//HA, hardware sets access flag, we dont need this i think we can handle in code: bit [39] -> 0b0
	//HD, hardware manages dirty bit, we will handle this i think maybe [40] -> 0b0

	//I think the rest are all 0 since we DS is 0

    //old: 00000000 00000000 00000000 00000000 00000000 11000000 00010000 00010000
    //new: 00000000 00000000 00000000 00001000 01010000 00010000 00100000 00010000
    //ind: 43210987 65432109 87654321 09876543 21098764 32109876 54321098 76543210
    //	       ^60        ^50         ^40        ^30       ^20        ^10        ^0
	//TCR reg - >0x850102010 
